import threading


threading.current_thread()				获取当前线程信息
threading.active_count()				获取当前线程数量

================================================================================

创建一个线程对象

t1 = threading.Thread(target=func,args=(1,))

target 线程需要执行的方法
args   方法内需要传入的参数_元祖类型

================================================================================

开始运行线程

t1.start()

================================================================================

谁调用该方法就阻塞谁的线程,直到 t1 执行完

t1.join()

================================================================================

守护线程,设置为 True 后,主线程结束, t1 就不继续执行线程代码了

t1.setDaemon(True)	必须在 start 方法前面

================================================================================
================================================================================

创建自定义类

class myThread(threading.Thread):		继承父类

    def __init__(self,num):			构造函数
        threading.Thread.__init__(self)
        self.num = num

    def run(self):				线程函数
        print('running on number: %s' % self.num)
        time.sleep(3)

================================================================================

================================================================================

线程锁

r = threading.Lock()			创建一个线程锁
r = threading.RLock()			创建一个递归锁(可重用的锁)

r.acquire()				开启线程锁，在代码块未结束之前，其他线程无法获取CPU资源
r.release()				解除线程锁




================================================================================

信号量

semaphore=threading.Semaphore(num)			num 控制多少个线程
semaphore=threading.BoundedSemaphore(num)		num 控制多少个线程

semaphore.acquire()					开启线程锁，在代码块未结束之前，其他线程无法获取CPU资源
semaphore.release()					解除线程锁

================================================================================

条件变量同步

lock_con=threading.Condition()

lock_con.acquire()					开启线程锁，在代码块未结束之前，其他线程无法获取CPU资源
lock_con.release()					解除线程锁
lock_con.wait()						条件不满足时调用，线程会释放锁并进入等待阻塞；
lock_con.notify()					条件创造后调用，通知等待池激活一个线程；
lock_con.notifyAll()					条件创造后调用，通知等待池激活所有线程。

================================================================================

同步条件(Event)

event=threading.Event()

event.isSet()						返回event的状态值；
event.wait()						如果 event.isSet()==False将阻塞线程；
event.set()						设置event的状态值为True，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；
event.clear()						恢复event的状态值为False。

================================================================================






================================================================================



================================================================================